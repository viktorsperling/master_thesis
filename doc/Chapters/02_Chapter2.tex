% \glsresetall
\chapter{State of technology} % Main chapter title
\label{Chapter2}

\lhead{Chapter 2. \emph{State of technology}}

In this chapter, the current state of technologies which can provide possible solutions for the issue of redundant resources in a micro frontend landscape is explained. Additionally, an overview about the used Luigi framework is given.

\section{Micro frontend framework Luigi}
\label{mf_framework_luigi}

Currently there are different micro frontend frameworks available on the market, including but not limited to \textbf{Bit, SystemJS, Webpack 5 Module Federation, Piral, Single SPA} and \textbf{Luigi}.\cite{top10_mffs}
For the implementation of the representative landscape the Luigi framework was used. Therefore, a short introduction to Luigi it is given here.

\subsection{Luigi}

Luigi is an open-source JavaScript framework for micro frontends, consisting of two main parts, the \textbf{Luigi Core} and the \textbf{Luigi Client}. It provides a basis to integrate micro frontends, also called \textbf{Nodes} in this context. Both parts serve different purposes in the micro frontend landscape.\cite{luigi_doc_overview}

\subsubsection{Core}

The \textbf{Luigi Core} is the basis of the whole landscape. It defines the main app, which will serve as an entry point for the user. The possibilities for, applicable configurations of this part are the following:

\begin{itemize}[noitemsep]
	\item Navigation - enables navigation between micro frontends
	\item Authorization - enables authorization for the landscape
	\item Localization - providing translations to display its applications in multiple languages
	\item General settings - e.g. header display configurations, enable loading indicators for the micro frontends, etc.
	\item Luigi Core API - providing functions for the core app to interact with the framework and access its features
\end{itemize} 

The core application inside the landscape is determined via the \texttt{luigi.config.js}. Any project containing it can fulfill this role, which is the only prerequisite. In the context of the framework, this app is later referred to as the \textbf{Core}.
Following this principle, the project structure of the \textbf{Core} could look as shown in listing \ref{list:luigi_core_structure}.\footnote{This example is taken directly from the implemented core project.}  

\begin{lstlisting}[language=Bash, caption=Project structure for a Luigi Core application including the \texttt{luigi.config.js}, label=list:luigi_core_structure,  xleftmargin=.01\textwidth, xrightmargin=.01\textwidth]
	- react-core-mf
		- [...]
		- node_modules
		- public
			- [...]
			- index.html
			- luigi.config.js
		- [...]
		- src
\end{lstlisting}

In the \texttt{luigi.config.js} itself the above mentioned possible configurations are defined.\cite{luigi_doc_core}

\subsubsection{Client}

The Luigi Client serves as the connection between the framework and its micro frontends. In order to establish the connection, a micro frontend has to import and initialize the Client. This will grant the micro frontend access to the \textbf{LuigiClient} object during the runtime. The micro frontend can then interact with the framework to e.g. set a global state, add event listeners or enable navigation between other micro frontends in the landscape.

An import of the Luigi Client can be accomplished via different methods. The most straightforward approach is the direct import with a HTML script tag. Another option would be the import of the local package manager dependency.\cite{luigi_client}

\begin{lstlisting}[caption=Import methods of the Luigi Client, label=list:import_luigi_client,  xleftmargin=.01\textwidth, xrightmargin=.01\textwidth]
	<!-- Via the HTML script tag -->
	<script src="https://unpkg.com/@luigi-project/client@1.17.0/luigi-client.js">
	</script>
	
	<!-- Via the package manager -->
	import LuigiClient from "@luigi-project/client";
\end{lstlisting}

\subsection{Architecture}

After the short introduction of the framework's core components, a general architecture of a landscape using Luigi is provided below.

\begin{figure}[!h]
	\centering
	\includegraphics[width=1.05\textwidth]{Figures/Luigi_Architektur.png}
	\caption{Architecture of the Luigi Framework \cite{luigi_architecture}}
	\label{fig:luigi_architecture_fig}
\end{figure}

As can be seen in figure \ref{fig:luigi_architecture_fig}, the displayed micro frontends in the Web App have a distinguished position in the Micro Frontends Container. The embedded projects can either be integrated via iFrames or as Web Components.
Via the provided dashboard (Navigation Frame), the Luigi Core features are used. Through it, the navigation or search feature can be accessed.

As described in the first chapter of this transcript, the issue in such a landscape are the redundantly imported libraries of the embedded micro frontends. The reason for this problem is that each node is an isolated application.
For instance, navigating to the first micro frontend, followed by the second one, will load the bundled projects with their corresponding dependencies. In this case, the browser has no way to distinguish if a loaded resource is already present or not. The reason for that is the bundling of projects which makes the references indistinguishable to the browser.
The sections below will introduce methods of resolving this issue. 

\section{Content Delivery Networks}
\label{cdn_intro}

One way of avoiding redundant libraries can be a central source, where all resources are stored and can be requested via an API. Such a concept exists in the idea of Content Delivery Networks (CDNs).
Since the resources are loaded via the CDN API, a dependency is available under a unique URL. Loading a dependency twice means the browser requests the resource from the same URL with the same parameters. Therefore, the browser can determine if the given resource is already present and decide to either load it from the CDN or from the browser cache, if it is already loaded.\cite{caching_in_browser}

Nonetheless, a CDN has its limits which have to be considered. Costs can play a key role in the decision process.
Even though free CDN services like \textbf{Unpkg.com} or \textbf{cdnjs} are valid options, the advantages of using these might differ depending on the business case.
For instance, those services might solve the issue of redundant libraries in a micro frontend landscape, but do not necessarily improve the user experience of the application. 
Since the resources would be loaded from a cloud based service, the server location has significant influence on the latency of the requests. Therefore, depending from where the website is accessed, this circumstance could lead to a performance decrease when initially loading the page.\cite{cdn_general}

Also the technological dependency on a public cloud based CDN has to be considered. Most cloud based services are scalable and replicable. However, a down time could lead to immense costs for a platform provider relying on a public CDN to deliver the platform resources.
Besides, it is never guaranteed that certain dependencies are always available on the public CDN.

Another option is self-hosting a CDN and providing all required resources independently. A business would need to acquire hardware-resources (physically or via a hardware-as-a-service provider like Amazon Web Services), maintain the servers, fill the CDN with the necessary content and keep it up to date. However costs attached to this scenario can be immense and exclude this method due to cost inefficiency.\cite{Meassuring_a_commercial_CDN}

\section{Web Components}

Another option to address the issue of redundancies are Web Components. Consisting of the following four standards, they provide reusable elements closed in HTML tags.\cite{mdn_web_docs}

\begin{itemize}[noitemsep]
	\item Custom Elements
	\item Shadow DOM
	\item HTML Template
	\item ES Modules
\end{itemize}


The necessary feature to achieve the goal of avoiding the issue is mainly provided by the \textbf{Custom Elements} standard of Web Components, therefore a short explanation of its behavior is given here.

\subsection{Custom Elements}

This standard of Web Components provides an API via which new HTML tags can be defined and registered by the \texttt{CustomElementRegistry}. Since a single tag name can only be registered once, multiple registrations of the same element would lead to an exception, thereby making already registered tags reusable for the whole micro frontend landscape without reloading the code of the registered element.\cite{google_reusable_wcs}

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.6\textwidth]{Figures/customElements_registered.drawio.png}
	\caption{Simple micro frontend landscape using Web Components}
	\label{fig:same_wc_example}
\end{figure}

Figure \ref{fig:same_wc_example} shows a simple micro frontend landscape with Luigi using Web Components. As displayed, both micro frontends are registering the same tag name \texttt{custom-element} using the \texttt{customElements} object. This object is a read-only property of the \texttt{Window} interface.
The scenario shown will cause a  \texttt{DOMException}, making it impossible to register the same tag twice.

The registration of Web Components follows the \textit{"first come, first served"} principle: The first micro frontend to register a tag name defines this tag and cannot be overwritten without reloading the page.\cite{mdn_web_docs_define}

\subsection{Objections}

There is still a niche case which can be raised as an objection. What if, even though the tag name is the same, the elements themselves are different? This is a justified objection to the example above. Therefore, it is up to the developers to use the standard properly.

Assuming a common micro frontend landscape where every micro frontend is developed by independent, isolated teams, using heterogenic frameworks, the mentioned issue might occur. Two teams use Web Components and try to register different elements under the same tag name in the same landscape. This requires organizational interference on team level.

One way would be to define a namespace for every team when creating Web Components e.g. Team 1 has the namespace \texttt{team-1}, causing a Web Component registered by the micro frontend of Team 1 to be named \texttt{team-1-tagname}. This could lead to redundancies, because there is no way of assuring that the \texttt{team-1-tagname} and \texttt{team-2-tagname} Web Components are not the same.\cite{wc_best_practices}

A better way might be to assign a common Web Components library like \textbf{UI5 Web Components}. That way, the registered elements are provided by the library and are limited to a set of unique registrable tags. If another micro frontend would try and register an already registered element of the library, a warning is thrown but no error occurs.

Most Web Component libraries also offer so called scoping options. This feature is employed, when versions of the used components differ between micro frontends. It enables the developers to customize their Web Components and register them under different tags. With this feature, it is made possible to register components according to their respective versions, by adding a version-specific suffix. That, of course, might lead to redundancies again. But it also reduces the dependency of the developer teams to always use the latest version of the component library or the first registered element in the landscape. \cite{ui5_webcomponents_scoping} \cite{openwc_scoping}

\section{Webpack Module Federation}
\label{wmf_chap_2}

A rather new way of creating micro frontends is the \textbf{Webpack 5 Module Federation (WMF)}. With the release of version 5 on October 10, 2020, this technology added certain features which improved its usage for developing micro frontends.\cite{wmf_concepts}

Since the main focus of this document is to propose methods of avoiding redundancies in micro frontend landscapes, an introduction of this WMF feature is given here.

The basic concept of the new WMF involves so called \texttt{hosts} and \texttt{remotes}. These terms are comparable to the \textbf{Luigi Core} and \textbf{Luigi Nodes} principle, previously introduced in section \ref{mf_framework_luigi}. In case of WMF, the \texttt{host} aka \texttt{shell} represents the \textbf{Core} or basis of the micro frontend landscape and the \texttt{remotes} or \texttt{micro frontends} are the \textbf{Nodes} integrated or loaded into it. 
Still, a direct comparison is not entirely possible since both frameworks are similar functionality-wise, but work differently in their cores. For instance, when using WMF, one is tied to use the Webpack bundler, since the necessary configuration is done in the \texttt{webpack.config.js}. This restriction is applied to every micro frontend in the WMF micro frontend landscape, not only to the \texttt{host}.

WMF can be used in combination with most of the common UI Frameworks. Since the implementation for this thesis was done with Angular, the further examples and explanations will be Angular-based.

As noted before WMF is a micro frontend framework, which offers means to solve the issue of redundant libraries in its landscapes.
This feature is enabled and configured, as well as the rest of the WMF, via the \texttt{webpack.config.js}. When configuring the components of the landscape, it is possible to define a section where shared dependencies are described. These dependencies can be defined in different ways. For instance, it is possible to define a strict version of the dependency, which would result in the framework loading this specific version. Or one can define a less restricted dependency, which would mean that if another \texttt{remote} loads the same dependency but in a different version, the framework would automatically apply the highest major version of the dependency to both micro frontends.

\begin{lstlisting}[language=JavaScript, caption=Example of sharing dependencies configured in the \texttt{webpack.config.js}, label=list:shared_mapping_wmf,  xleftmargin=.01\textwidth, xrightmargin=.01\textwidth]
	  shared: share({
			"@angular/core": { 
				singleton: true, 
				strictVersion: false, 
				requiredVersion: '12.2.0' 
			},
			"@angular/common": { 
				singleton: true, 
				strictVersion: false, 
				requiredVersion: '12.2.0' 
			},
			"@fundamental-ngx/core": { 
				singleton: true, 
				strictVersion: false, 
				requiredVersion: '0.33.0-rc.214' 
			},
			
			...sharedMappings.getDescriptors()
		})
\end{lstlisting}

Listing \ref{list:shared_mapping_wmf} is an example of how to share libraries in a restrictive way. To provide a less restricted configuration, a simple array of the shared dependency names suffices. But to ensure a redundant free landscape, these restrictions are necessary. Each configuration property will be explained below.

\begin{itemize}
	\item \texttt{singleton} - This property defines if the dependency should be able to be loaded more than once in different versions or not. If set to \texttt{true}, WMF will automatically pick the highest version of a major release of this dependency available and distribute it to the \texttt{remotes}.\cite{wmf_version_mismatch}
	
	\item \texttt{strictVersion} - This property defines if the dependency requires a specific version to work. If set to \texttt{true} WMF, will load the required version even if another dependency mapping with the same name is present. This can lead to conflicts with the \texttt{singleton} property, if configured poorly.
	
	\item \texttt{requiredVersion} - This property defines the required version of the dependency. When working with a package manager (e.g. NPM), this version has to be aligned with the locally installed version of the dependency. If the \texttt{strictVersion} property is set to \texttt{false}, this property defines the minimum version for the micro frontend. 
	
	It has to be mentioned that WMF is able to distinguish between major releases. If a higher version of the same major release is available, it will be loaded (e.g. \texttt{@angular/common@12.3.1}). For instance, if the next higher version is of a different major release e.g. 13.X.X, WMF would not consider to load it for the \texttt{remotes} which have the \texttt{requiredVersion} of release 12.X.X configured.
\end{itemize}

Now, when it comes to sharing the dependencies inside the micro frontend landscape, each \texttt{remote} has to participate. That means each micro frontend has to define its required dependencies in their respective versions. Additionally, it has to be mentioned that the micro frontends themselves have to use dynamic imports when importing shared dependencies. Through the asynchronous behavior of the import, Webpack has time to pick the correct version of the dependency inside the landscape.\cite{wmf_concepts}
Analyzing this statement in combination with the information taken from \ref{list:shared_mapping_wmf}, it becomes obvious that multiple versions of the same framework can exist in a landscape. Figure \ref{fig:wmf_multiversions} illustrates this.

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\textwidth]{Figures/multi_version_diagramm.drawio.png}
	\caption{WMF way of handling multi-versions}
	\label{fig:wmf_multiversions}
\end{figure}

As it can be seen, WMF always picks the latest major release, assuming the respective micro frontends have a similar configuration as shown in listing \ref{list:shared_mapping_wmf} applied. If, for instance, \textbf{MF3} has its \texttt{strictVersion} property set to \texttt{true}, it would cause the loading of its libraries too.

There are side effects to sharing the same dependency over the whole micro frontend landscape. One of which is the increase in bundle sizes, since every \texttt{remote} bundles its local dependencies. WMF then picks the one to serve during the runtime of the landscape.
This impact has a trade-off tough. Returning users can benefit from cached dependencies.\cite{wmf_multi_versions}
 
